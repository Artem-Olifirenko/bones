#!/bin/sh -e
# ВАЖНО!
# Данный скрипт является стандартным для всех микросервисов данного типа, его нельзя менять, предварительно не обсудив
# с тимлидом.
REPO_NAME="grpc-skeleton"
GRPC_CLIENT_BASEDIR="internal/specs/grpcclient"
PROTO_PATHS="internal/api/grpc internal/specs/grpcclient internal/specs/kafkacl"
UNIT_COVERAGE_MIN=80
USED_SKELETON_VER={BS_SKELETON_VER}

CGO_ENABLED=0

PPROF_UI_PORT=77345
PPROF_DEFAULT_PORT=8080
PPROF_DEFAULT_CPU_DURATION=5

# Запуск buf
run_buf(){
  docker run --rm -w "/work" -v "$(pwd):/work" docker.citik.ru/base/buf:latest $@
}

# Выполняет команду от имени root
run_as_root(){
  docker run --rm -w "/work" -v "$(pwd):/work" alpine:latest $@
}

# Обрабатывает прото файлы
process_proto_files(){
  local COMMAND="$1"
  local PROTO_DIR="$2"

  if [ ! -d "$PROTO_DIR" ]; then
    return 0
  fi

  run_buf $@
}

# Генерация прото файлов
gen_proto(){
  for CURPATH in ${PROTO_PATHS}; do
    echo "start process $CURPATH..."

    rm -Rf $CURPATH/gen/*
    process_proto_files lint "$CURPATH/proto"
    process_proto_files generate "$CURPATH/proto" --template "$CURPATH/proto/buf.gen.yaml"

    if [ -d "$CURPATH/gen" ]; then
          run_as_root chown -R "$(id -u)":"$(id -g)" "/work/$CURPATH/gen"
    fi

    echo "finish process $CURPATH..."
  done
}

# Генерация мок файлов для GRPC клиентов
gen_mock_grpc_client() {
  echo "run generate grpc client mock files"

  filepath="$GRPC_CLIENT_BASEDIR/mock.go"
  dirgen="$GRPC_CLIENT_BASEDIR/gen"
  if [ ! -d "$GRPC_CLIENT_BASEDIR" ]; then echo "directory $GRPC_CLIENT_BASEDIR not found"; return 0; fi
  if [ ! -d "$dirgen" ]; then echo "directory $dirgen not found"; return 0; fi

  echo "run generate $filepath file"
  echo "// Code generated by command \"run.sh gen_mock_grpc_client\". DO NOT EDIT." > $filepath
  # Исправляет косяк с подключением пакета mockgen в go1.14 https://github.com/golang/mock/issues/415
  echo "package grpcclient" >> $filepath
  echo "" >> $filepath
  echo "import (" >> $filepath
  echo "	_ \"go.uber.org/mock/mockgen/model\"" >> $filepath
  echo ")" >> $filepath

  grep -i "Client interface {" -R "$dirgen" | while read -r line ; do
    i=0
    for val in $line; do
      if [ "$i" = 0 ]; then suffix=${val#*/v[0-9]/}; path=${val%:type*}; path=${path#"$dirgen/"}; fi
      if [ "$i" = 1 ]; then class=$val; fi
      i=$((i+1))
    done
    filename=${suffix%.pb*}
    pathdest=${path%/$filename*}
    echo "//go:generate mockgen -typed -source=./gen/$path -destination=./mock/$pathdest/$filename.go $class" >> $filepath
  done

  echo "run go generate $filepath"
  go generate $filepath
}

# Запуск unit-тестов
unit(){
  echo "run unit tests"
  go test ./...
}

unit_race() {
  echo "run unit tests with race test"
  go test -race ./...
}

# Запуск go-lint
lint(){
  echo "run linter"
  go mod vendor
  docker run --rm -v $(pwd):/work:ro -w /work docker.citik.ru/base/golangci-lint:latest golangci-lint run -v
  rm -Rf vendor
}

# Запуск линтера proto файлов
lint_proto(){
  echo "run proto linter"
  for CURPATH in ${PROTO_PATHS}; do
    process_proto_files lint "$CURPATH/proto"
  done
}

lint_helm_values(){
  echo "run helm values linter"
  local status=true
  for env in $(grep 'required:"true"' cmd/*/config.go | grep -E 'CL_\w+' -o); do
    for f in $(ls -1 ci/helm/values/values-*); do
      grep --quiet "$env" "$f" || { status=false; echo "missing" "$env" in "$f"; }
    done;
  done;
  if ! "$status" ; then
    return 1
  fi;
}

fmt() {
  echo "run go fmt"
  go fmt ./...
}

vet() {
  echo "run go vet"
  go vet ./...
}

unit_coverage() {
  echo "run test coverage"
  go test -coverpkg=./... -coverprofile=cover_profile.out.tmp $(go list ./internal/...)
  # remove generated code and mocks from coverage
  < cover_profile.out.tmp grep -v -e "mock" -e "\.pb\.go" -e "\.pb\.validate\.go" > cover_profile.out
  rm cover_profile.out.tmp
  CUR_COVERAGE=$( go tool cover -func=cover_profile.out | tail -n 1 | awk '{ print $3 }' | sed -e 's/^\([0-9]*\).*$/\1/g' )
  rm cover_profile.out
  if [ "$CUR_COVERAGE" -lt $UNIT_COVERAGE_MIN ]
  then
    echo "coverage is not enough $CUR_COVERAGE < $UNIT_COVERAGE_MIN"
    return 1
  else
    echo "coverage is enough $CUR_COVERAGE >= $UNIT_COVERAGE_MIN"
  fi
}

deps_check() {
  echo "run dependency analyzer"
  go list -json -deps ./cmd/"$REPO_NAME" | docker run -i --rm \
      -v $(pwd)/.nancy-ignore:/.nancy-ignore \
      sonatypecommunity/nancy:v1-alpine nancy sleuth
}

# Запуск проверки актуальности версии скелетона
skeleton_ver_check(){
  if [ "$REPO_NAME" != "grpc-skeleton" ]; then
    echo "run check for skeleton updates"
    local ACTUAL_SKELETON_VER=$( git ls-remote --tags --refs --sort="-version:refname" ssh://git@git.citilink.cloud:22/shared/grpc-skeleton.git | head -n 1 | awk -F/ '{print$NF}' )
    if [ "$ACTUAL_SKELETON_VER" = "" ]; then
      return 1
    fi
    if [ "$USED_SKELETON_VER" = "$ACTUAL_SKELETON_VER" ]; then
      echo "$(tput setab 2) actual version of the skeleton is used: $USED_SKELETON_VER $(tput sgr0)"
    else
      echo "$(tput setab 3) new version of the skeleton is available: $ACTUAL_SKELETON_VER, you are using: $USED_SKELETON_VER $(tput sgr0)"
    fi
  fi
}

# Запуск всех тестов
test(){
  fmt
  vet
  unit
  unit_race
  unit_coverage
  deps_check
  lint
  lint_proto
  lint_helm_values
  security_scan
  skeleton_ver_check
}

# Подтянуть зависимости
deps(){
  go get ./...
}

# Собрать исполняемый файл
build(){
  deps
  go build ./cmd/grpc-skeleton
}

# Запустить сбор метрик нагрузки на cpu из pprof
pprof_cpu(){
  local SECS=${3:-$PPROF_DEFAULT_CPU_DURATION}
  local HOST=$2

  go tool pprof -http :$PPROF_UI_PORT $HOST/debug/pprof/profile?seconds=$SECS
}

# Запустить сбор метрик памяти из pprof
pprof_heap(){
  local HOST=$2

  go tool pprof -http :$PPROF_UI_PORT $HOST/debug/pprof/heap
}

# Собрать docker образ
build_docker() {
  build
  docker build -t "$REPO_NAME:local" .
  rm ./"$REPO_NAME"
}

# Запустить проверку локального образа на уязвимости
security_scan() {
  echo "run security scan"
  build_docker
  docker save "$REPO_NAME:local" > image.tar
  docker run --rm -v "$(pwd):/work" aquasec/trivy image --input /work/image.tar
  rm image.tar
}

# Добавьте сюда список команд
using(){
  echo "Укажите команду при запуске: ./run.sh [command]"
  echo "Список команд:"
  echo "  unit - запустить unit-тесты"
  echo "  unit_race - запуск unit тестов с проверкой на data-race"
  echo "  unit_coverage - запуск unit тестов и проверка покрытия кода тестами"
  echo "  lint - запустить все линтеры"
  echo "  lint_proto - запустить линтер proto файлов"
  echo "  lint_helm_values - запустить проверку env-переменных"
  echo "  test - запустить все тесты"
  echo "  deps - подтянуть зависимости"
  echo "  build - собрать приложение"
  echo "  build_docker - собрать локальный docker образ"
  echo "  fmt - форматирование кода при помощи 'go fmt'"
  echo "  vet - проверка правильности форматирования кода"
  echo "  deps_check - анализ зависимостей на уязвимости"
  echo "  security_scan - запустить проверку локального образа на уязвимости"
  echo "  gen_proto - генерация прото файлов (для клиентов и сервера)"
  echo "  gen_mock_grpc_client - генерация мок файлов (для GRPC клиентов)"
  echo "  skeleton_ver_check - проверить актуальность версии скелетона"
  echo "  pprof_cpu HOST [SECONDS] - сбор метрик нагрузки на cpu из pprof"
  echo "  pprof_heap HOST - запустить сбор метрик памяти из pprof"
}

############### НЕ МЕНЯЙТЕ КОД НИЖЕ ЭТОЙ СТРОКИ #################

command="$1"
if [ -z "$command" ]
then
 using
 exit 0;
else
 $command $@
fi
